
<!doctype html>
<html lang="fr" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.5">
    
    
      
        <title>Théorie - Formation Deep Learning</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.21aed14c.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.196e0c26.min.css">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-1-introduction-au-deep-learning-prise-en-main-de-tensorflow-et-keras" class="md-skip">
          Aller au contenu
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Formation Deep Learning" class="md-header-nav__button md-logo" aria-label="Formation Deep Learning">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Formation Deep Learning
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Théorie
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Rechercher" placeholder="Rechercher" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
    
    <a href=".." class="md-tabs__link">
      Acceuil
    </a>
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
      
        
      
      <a href="./" class="md-tabs__link md-tabs__link--active">
        Module 1
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Formation Deep Learning" class="md-nav__button md-logo" aria-label="Formation Deep Learning">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Formation Deep Learning
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." class="md-nav__link">
      Acceuil
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    <label class="md-nav__link" for="nav-2">
      Module 1
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Module 1" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Module 1
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Théorie
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      Théorie
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table des matières">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table des matières
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#preliminaires-notations-et-conventions" class="md-nav__link">
    Préliminaires, notations et conventions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#le-commencement-du-debut-les-neurosciences-le-fonctionnement-dun-neurone-biologique" class="md-nav__link">
    Le commencement du début : les neurosciences &amp; le fonctionnement d'un neurone biologique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#le-neurone-de-mcculloch-pitts-et-le-perceptron" class="md-nav__link">
    Le neurone de McCulloch-Pitts et le perceptron
  </a>
  
    <nav class="md-nav" aria-label="Le neurone de McCulloch-Pitts et le perceptron">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#le-neurone-de-mcculloch-pitts" class="md-nav__link">
    Le neurone de McCulloch-Pitts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#le-perceptron" class="md-nav__link">
    Le Perceptron
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalisation-les-reseaux-de-neurones-denses" class="md-nav__link">
    Genéralisation : Les réseaux de neurones denses
  </a>
  
    <nav class="md-nav" aria-label="Genéralisation : Les réseaux de neurones denses">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fonction-dactivation-et-etape-feedforward" class="md-nav__link">
    Fonction d'activation et étape feedforward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fonction-de-perte" class="md-nav__link">
    Fonction de perte
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descente-du-gradient-stochastique" class="md-nav__link">
    Descente du gradient stochastique
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resume" class="md-nav__link">
    Résumé
  </a>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Module1_2/" class="md-nav__link">
      Pratique
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table des matières">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table des matières
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#preliminaires-notations-et-conventions" class="md-nav__link">
    Préliminaires, notations et conventions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#le-commencement-du-debut-les-neurosciences-le-fonctionnement-dun-neurone-biologique" class="md-nav__link">
    Le commencement du début : les neurosciences &amp; le fonctionnement d'un neurone biologique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#le-neurone-de-mcculloch-pitts-et-le-perceptron" class="md-nav__link">
    Le neurone de McCulloch-Pitts et le perceptron
  </a>
  
    <nav class="md-nav" aria-label="Le neurone de McCulloch-Pitts et le perceptron">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#le-neurone-de-mcculloch-pitts" class="md-nav__link">
    Le neurone de McCulloch-Pitts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#le-perceptron" class="md-nav__link">
    Le Perceptron
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalisation-les-reseaux-de-neurones-denses" class="md-nav__link">
    Genéralisation : Les réseaux de neurones denses
  </a>
  
    <nav class="md-nav" aria-label="Genéralisation : Les réseaux de neurones denses">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fonction-dactivation-et-etape-feedforward" class="md-nav__link">
    Fonction d'activation et étape feedforward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fonction-de-perte" class="md-nav__link">
    Fonction de perte
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descente-du-gradient-stochastique" class="md-nav__link">
    Descente du gradient stochastique
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resume" class="md-nav__link">
    Résumé
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="module-1-introduction-au-deep-learning-prise-en-main-de-tensorflow-et-keras"><strong>Module 1 : Introduction au deep learning, prise en main de Tensorflow et Keras</strong></h1>
<h2 id="preliminaires-notations-et-conventions">Préliminaires, notations et conventions</h2>
<p>Dans la suite de ces modules, on se place de le cadre d'un <strong>apprentissage</strong> dit <strong>supervisé</strong>, on considérera donc la problématique suivante :</p>
<div class="admonition note">
<p class="admonition-title">Problématique</p>
<p>On note <span class="arithmatex">\(\mathbf{R}^{j}\)</span> l'espace vectoriel réel de dimension <span class="arithmatex">\(j\)</span>. Etant donné le dataset (fini) suivant.</p>
<div class="arithmatex">\[
    \mathcal{X} = \lbrace (\mathbf{x}_{i}, \mathbf{y}_{i})\rbrace_{i \in I} \quad (\mathbf{x}_{i}, \mathbf{y}_{i}) \in \mathbf{R}^{m} \times \mathbf{R}^{k}
\]</div>
<p>On suppose que <span class="arithmatex">\(\mathbf{x}_{i}\)</span> et <span class="arithmatex">\(\mathbf{y}_{i}\)</span> sont reliés entre eux par une fonction <strong>inconnue</strong> <span class="arithmatex">\(f : \mathbf{R}^{m} \rightarrow \mathbf{R}^{k}\)</span> vérifiant la relation suivante.</p>
<div class="arithmatex">\[
    f(\mathbf{x}_{i}) = \mathbf{y}_{i} + \varepsilon
\]</div>
<p>Déterminer un algorithme estimant <span class="arithmatex">\(f\)</span>, c'est à dire produisant une fonction</p>
<div class="arithmatex">\[
    \hat{f} : \mathbf{R}^{m} \rightarrow \mathbf{R}^{k}
\]</div>
<p>telle que <span class="arithmatex">\(\hat{f}(\mathbf{x}_{i}) = \hat{\mathbf{y}}_{i}\)</span> avec <span class="arithmatex">\(\hat{\mathbf{y}}_{i}  \simeq \mathbf{y}_{i}\)</span>.</p>
</div>
<p>Pour déterminer <span class="arithmatex">\(\hat{f}\)</span>, on se place alors dans le cadre des réseaux de neurones. On utilisera les conventions suivantes.</p>
<ul>
<li><span class="arithmatex">\(I = \lbrace 1, \dots, n \rbrace\)</span> est un ensemble discret fini, <span class="arithmatex">\(|I| = n\)</span> est le nombre d'<strong>observations</strong> dans le dataset.</li>
<li>Le couple <span class="arithmatex">\((\mathbf{x}_{i}, \mathbf{y}_{i})\)</span> est alors appelé la <span class="arithmatex">\(i\)</span>-ième observation du dataset.</li>
<li><span class="arithmatex">\(\mathbf{x}_{i} = (x_{i,1}, \dots, x_{i,m}) \in \mathbf{R}^{m}\)</span> est l'ensemble des <strong>features</strong> (caractéristiques) de la <span class="arithmatex">\(i\)</span>-ième observation du dataset et <span class="arithmatex">\(\mathbf{y}_{i} = (y_{i,1}, \dots, y_{i,k}) \in \mathbf{R}^{k}\)</span> est la <strong>cible</strong> de la <span class="arithmatex">\(i\)</span>-ième observation du dataset.</li>
<li>La fonction <span class="arithmatex">\(\hat{f}\)</span> est un <strong>modèle</strong> de <span class="arithmatex">\(f\)</span>, et <span class="arithmatex">\(\hat{f}(\mathbf{x}_{i}) = \hat{\mathbf{y}}_{i}\)</span> est une <strong>prédiction</strong>.</li>
</ul>
<h2 id="le-commencement-du-debut-les-neurosciences-le-fonctionnement-dun-neurone-biologique">Le commencement du début : les neurosciences &amp; le fonctionnement d'un neurone biologique</h2>
<p>Avant de parler des neurones artificiels, jetons un coup d'œil rapide sur un neurone biologique.</p>
<p>Il s'agit d'une cellule d'apparence inhabituelle que l'on trouve surtout dans les cerveaux d'animaux. Elle est composée d'un corps cellulaire contenant le noyau et la plupart des éléments du complexe cellulaire, de nombreuses extensions de ramification appelées <strong>dendrites</strong>, plus une très longue extension appelée l'<strong>axone</strong>. La longueur de l'axone peut être juste quelques fois plus longue que la cellule, ou jusqu'à des dizaines de milliers de fois plus.</p>
<p>Près de son extrémité, l'axone se détache en de nombreuses branches appelées <strong>télodendries</strong>, et à l'extrémité de ces branches se trouvent de minuscules structures appelées <strong>bornes synaptiques</strong> (ou simplement <strong>synapses</strong>), qui sont connectées à la dendrite ou aux corps d'autres neurones. Les neurones biologiques produisent de courtes impulsions électrique appelées <strong>potentiels d'action</strong> (PA, ou simplement des signaux) qui se déplacent le long des axones et font en sorte que les synapses émettent des signaux chimiques appelés neurotransmetteurs. <strong>Quand un neurone reçoit une quantité suffisante de ces neurotransmetteurs en quelques millisecondes, il envoie ses propres impulsions électriques</strong> (en fait, cela dépend des neurotransmetteurs, car certains d'entre eux empêchent le neurone de s'activer).</p>
<p><img alt="Screenshot" src="../images/1117px-Blausen_0657_MultipolarNeuron.png" /></p>
<p>Ainsi, les neurones biologiques individuels semblent se comporter de manière assez simple, mais <strong>ils sont organisés en un vaste réseau de plusieurs milliards</strong>, chaque neurone étant généralement connecté à des milliers d'autres neurones. Des calculs très complexes peuvent être effectués par un réseau de neurones assez simples, de la même façon que d'une fourmilière peut émerger les efforts combinés de simples fourmis. L'architecture des réseaux neuronaux biologiques (BNN) fait toujours l'objet de recherches actives, mais certaines parties du cerveau ont été cartographiées et il semble que les neurones sont souvent organisés en couches consécutives, spécialement dans le <strong>cortex cérébral</strong> (la couche externe de votre cerveau).</p>
<p><img alt="Screenshot" src="../images/image_module1/Cajal_cortex_drawings.png" /></p>
<h2 id="le-neurone-de-mcculloch-pitts-et-le-perceptron">Le neurone de McCulloch-Pitts et le perceptron</h2>
<p>L'idée première de laquelle découle l'invention des neurones artificiels est la volontée d'avoir un algorithme de classification binaire.</p>
<h3 id="le-neurone-de-mcculloch-pitts">Le neurone de McCulloch-Pitts</h3>
<p>Le premier article scientifique modélisant de façon mathématique un neurone biologique a été rédigé en 1943 par le <strong>neurobiologiste Warren McCulloch et le mathématicien Walter Pitts</strong>.</p>
<p><img alt="Screenshot" src="../images/image_module1/3-Figure2-1.png" /></p>
<p>Le neurone de McCulloch-Pitts est simple : Le neurone correspond à une fonction ayant une ou plusieurs entrée binaires et une sortie binaire (0 ou 1). Le neurone ne s'active (produit une sortie) que si le nombre d'entrée active dépasse un certain seuil.</p>
<p>On rappelle que la fonction de Heaviside <span class="arithmatex">\(H\)</span> est définie par :</p>
<div class="arithmatex">\[
    \begin{array}{ccccc} H &amp; : &amp; \mathbf{R} &amp; \to &amp; [0,1] \\ &amp; &amp; x &amp; \mapsto &amp; H(x) \\ \end{array}
\]</div>
<p>avec</p>
<div class="arithmatex">\[
    H(x) = \begin{cases} 1 &amp; x \geq 0, \\
                         0 &amp; x &lt; 0.\end{cases}
\]</div>
<p><img alt="Screenshot" src="../images/image_module1/heaviside.svg" /></p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>Un neurone de McCulloch-Pitts est donné par :</p>
<ol>
<li>des entrées binaires <span class="arithmatex">\((x_{1}, \dots, x_{m})\)</span>,</li>
<li>un réel <span class="arithmatex">\(\vartheta \in \mathbf{R}\)</span>,</li>
<li>une sortie <span class="arithmatex">\(\hat{y}\)</span>, définie par l'équation suivante.</li>
</ol>
<div class="arithmatex">\[
    \hat{y} = H(\sum_{i=1}^{m} x_{i} - \vartheta), \quad \forall i \in I, x_{i} \in \lbrace 0,1 \rbrace
\]</div>
<p>où <span class="arithmatex">\(H\)</span> est la fonction de Heaviside, et <span class="arithmatex">\(\vartheta\)</span> est le seuil.</p>
<p>On dit que le neurone s'active si <span class="arithmatex">\(\sum_{i=1}^{m} x_{i} - \vartheta &gt; 0\)</span>.</p>
</div>
<p>Le neurone tel que défini par McCulloch et Pitts est considéré comme <strong>une simple porte logique</strong> : il n'y a pas d'algorithme associé afin de l'entraîner. Ils montrèrent cependant qu'un réseau constitué des neurones formels de leur invention a la même puissance de calcul qu'une machine de Turing, ie ce réseau est capable de calculer toutes les propositions logiques.</p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p>Modélisons les portes logiques ET et OU via les neurones de McCulloch-Pitts.</p>
<p>Quelle valeur de <span class="arithmatex">\(\vartheta\)</span> prendre ?</p>
<p><img alt="Screenshot" src="../images/image_module1/and_or_final.svg" /></p>
</div>
<div class="admonition note">
<p class="admonition-title">Définition</p>
<p>La fonction brisant la linéarité à la sortie du neurone, dans notre cas pour l'instant la fonction de Heaviside <span class="arithmatex">\(H\)</span>, sera appelée <strong>fonction d'activation</strong> du neurone.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Attention</p>
<p>Le neurone de McCulloch Pitts possède les limites suivantes :</p>
<ol>
<li>Impossibilité de fournir des entrées non booléennes.</li>
<li>Le seuil doit toujours être défini manuellement.</li>
<li>Toutes les entrées sont également importante, on ne peut pas assigner une importance plus grande à certaines entrées.</li>
</ol>
</div>
<h3 id="le-perceptron">Le Perceptron</h3>
<p>En 1958, puis 1962, Frank Rosenblatt généralise les travaux de McCulloch et Pitts en développant le <strong>Perceptron</strong>. Le Perceptron de Rosenblatt est essentiellement un neurone de McCulloch-Pitts, où les entrées <span class="arithmatex">\((x_{1}, \dots, x_{m})\)</span> peuvent cette fois ci prendre des valeurs réelles. De plus, chaque entrée est maintenant pondérée, le poids <span class="arithmatex">\(w_{i}\)</span> étant lui aussi à valeur réelle. Un poids positif (<span class="arithmatex">\(w_{i} &gt; 0\)</span>) reflétant une synapse excitatrice, tandis qu'un poids négatif (<span class="arithmatex">\(w_{i} &lt; 0\)</span>) représente lui une synapse inhibitrice.</p>
<div class="admonition note">
<p class="admonition-title">Définition</p>
<p>Un Perceptron est donné par :</p>
<ul>
<li>des entrées <span class="arithmatex">\((x_{1}, \dots, x_{m}) \in \mathbf{R}^{m}\)</span>,</li>
<li>des poids <span class="arithmatex">\((w_{1}, \dots, w_{m}) \in \mathbf{R}^{m}\)</span>,</li>
<li>un réel <span class="arithmatex">\(\vartheta \in \mathbf{R}\)</span>,</li>
<li>une sortie <span class="arithmatex">\(\hat{y}\)</span>, définie par l'équation suivante.</li>
</ul>
<div class="arithmatex">\[
    \hat{y} = H(\sum_{i=1}^{m} w_{i}x_{i} - \vartheta), \forall i \in I, (w_{i}, x_{i}) \in \mathbf{R}^{2}
\]</div>
<p>où <span class="arithmatex">\(H\)</span> est la fonction de Heavyside, et <span class="arithmatex">\(\vartheta\)</span> est le seuil.</p>
<p>On dit que le neurone s'active si <span class="arithmatex">\(\sum_{i=1}^{m} w_{i}x_{i} - \vartheta &gt; 0\)</span>.</p>
</div>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p>Modélisons la porte logique A et (non B) via le Perceptron.</p>
<p>Quelle valeur de <span class="arithmatex">\(\vartheta\)</span> prendre ?</p>
<p><img alt="Screenshot" src="../images/image_module1/and_not_final.svg" /></p>
</div>
<p><strong>Le Perceptron</strong>, contrairement au neurone de McCulloch-Pitts, <strong>est lui muni d'un algorithme d'entraînement</strong> afin de trouver les poids optimaux pour la prédiction.</p>
<p>La règle d'apprentissage du Perceptron prend en compte l'erreur faite durant la prédiction, et modifie les poids du neurone afin de réduire l'erreur. Plus précisément, le Perceptron reçoit une observation à la fois (ie la batchsize = 1) et sort une prédiction <span class="arithmatex">\(\hat{y}\)</span>. Pour chaque mauvaise prédiction, les poids sont changés en renforçant ceux qui auraient contribué le plus à une prédiction correcte.</p>
<p>Ainsi, pour passer de l'étape <span class="arithmatex">\(k\)</span> à l'étape <span class="arithmatex">\(k+1\)</span>, on mets à jour les poids via la formule suivante.</p>
<div class="arithmatex">\[
    w_{i}^{k+1} = w_{i}^{k} + \eta (y - \hat{y})x_{i}
\]</div>
<p>où :</p>
<ul>
<li><span class="arithmatex">\(w_{i}\)</span> est le poids de la connexion <span class="arithmatex">\(i\)</span>,</li>
<li><span class="arithmatex">\(x_{i}\)</span> est la valeur d'entrée de la connexion <span class="arithmatex">\(i\)</span>,</li>
<li><span class="arithmatex">\(\hat{y}\)</span> est la prédiction obtenue par <span class="arithmatex">\(H(\sum_{i=1}^{m} w_{i}x_{i} - \vartheta)\)</span>,</li>
<li><span class="arithmatex">\(y\)</span> est la cible de la prédiction,</li>
<li><span class="arithmatex">\(\eta\)</span> est le taux d'appentissage.</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<ol>
<li>Pour le neurone de McCulloch-Pitts, comme pour le Perceptron, la sortie <span class="arithmatex">\(\hat{y}\)</span> est binaire.</li>
<li>Un neurone de McCulloch-Pitts est un Perceptron où tous les poids sont égaux à 1.</li>
</ol>
<div class="arithmatex">\[
    w_{1} = \cdots = w_{n} = 1
\]</div>
<p><img alt="Screenshot" src="../images/image_module1/MP_Perceptron.svg" /></p>
<p>Schéma général d'un neurone de McCulloch-Pitts (haut) et d'un Perceptron (bas)</p>
</div>
<p>Un des premiers résultats lié au Perceptron est qu'il est capable de modéliser et de résoudre des problèmes où les données sont <strong>linéairement séparables</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Définition</p>
<ol>
<li>Une fonction binaire</li>
</ol>
<div class="arithmatex">\[
\hat{y} \, : \, \mathbf{R}^{n} \longrightarrow \lbrace 0,1 \rbrace
\]</div>
<p>est dite <strong>Perceptron calculable</strong> s'il existe un seuil <span class="arithmatex">\(\vartheta\)</span> et des poids <span class="arithmatex">\((w_{1}, \dots, w_{n}) \in \mathbf{R}^{n}\)</span> tels que l'hyperplan d'équation</p>
<div class="arithmatex">\[
\sum_{i=1}^{n} w_{i}x_{i} = \vartheta
\]</div>
<p>divise l'espace <span class="arithmatex">\(\mathbf{R}^{n}\)</span> en deux regions</p>
<div class="arithmatex">\[
\mathbf{R}^{n} = R_{0} \bigcup R_{1} = \lbrace \hat{y} =0 \rbrace \bigcup \lbrace \hat{y}=1 \rbrace
\]</div>
<ol>
<li>Un ensemble de points <span class="arithmatex">\((x_{1}, \dots, x_{n}) \in \mathbf{R}^{n}\)</span> pouvant être séparés par une fonction Perceptron calculabe est dit <strong>linéairement séparable</strong>.</li>
</ol>
</div>
<div class="admonition example">
<p class="admonition-title"> Ensemble de points linéairement séparables</p>
<p><img alt="Screenshot" src="../images/image_module1/lin_sep_final.svg" /></p>
</div>
<div class="admonition example">
<p class="admonition-title">Ensemble de points non linéairement séparables</p>
<p><img alt="Screenshot" src="../images/image_module1/no_lin_sep.svg" /></p>
</div>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<ol>
<li>
<p>Linéairement indépendant <span class="arithmatex">\(\implies\)</span> Linéairement séparable.</p>
</li>
<li>
<p>La réciproque est fausse : les points <span class="arithmatex">\(\lbrace (0,0), (1,0), (0,1) \rbrace\)</span> sont linéairement séparables dans <span class="arithmatex">\(\mathbf{R}^{2}\)</span>, mais ne sont pas linéairement indépendants.</p>
</li>
</ol>
</div>
<p>Cette propriété de séparabilité linéaire permet au Perceptron de résoudre certains problèmes de classification binaire.</p>
<div class="admonition note">
<p class="admonition-title">Théorème de convergence du Perceptron</p>
<p>Etant donné un problème de classification binaire avec des classes linéairement séparables, si une solution <span class="arithmatex">\((\vartheta^{\ast}, w_{1}^{\ast}, \dots, w_{n}^{\ast}) \in \mathbf{R}^{n+1}\)</span> existe, alors l'algorithme du Perceptron trouvera cette solution en un nombre fini <span class="arithmatex">\(h_{\mathrm{max}}\)</span> d'itérations.</p>
</div>
<p>En d'autres termes, si on a un ensemble de points que l'on sait linéairement séparable, et qu'en plus on sait qu'une solution existe, alors le Perceptron la trouvera.</p>
<p>Conceptuellement c'est un résultat important. Cependant, ce résultat a deux difficultées :</p>
<ol>
<li>Il est nécéssaire de savoir qu'ne  solution <span class="arithmatex">\((\vartheta^{\ast}, w_{1}^{\ast}, \dots, w_{n}^{\ast}) \in \mathbf{R}^{n+1}\)</span> existe. En effet, il existe des problèmes pour lesquels aucune solution par le Perceptron n'existe.</li>
<li>La seconde diffcultée est que, même si l'on sait que le Perceptron trouvera une solution en un nombre fini d'itérations, il nous est impossible de calculer <span class="arithmatex">\(h_{\mathrm{max}}\)</span> car il dépend du vecteur de solution <span class="arithmatex">\((\vartheta^{\ast}, w_{1}^{\ast}, \dots, w_{n}^{\ast}) \in \mathbf{R}^{n+1}\)</span>, qui nous est inconnu.</li>
</ol>
<div class="admonition danger">
<p class="admonition-title">Attention</p>
<p>La fonction XOR n'est pas Perceptron calculabe, sa table de vérité étant la suivante.</p>
<table>
<thead>
<tr>
<th align="center"><span class="arithmatex">\(x_{1}\)</span></th>
<th align="center"><span class="arithmatex">\(x_{2}\)</span></th>
<th align="center"><span class="arithmatex">\(x_{1} \oplus x_{2}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
<p><img alt="Screenshot" src="../images/image_module1/XOR.svg" /></p>
</div>
<p>Le problème de la fonction XOR a rapidement montré les limitations du Perceptron. Pour avoir plus de fléxibilité, l'idée est alors d'empiler de façon hiérarchique et en plusieurs couches des Perceptrons.</p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p><strong>Et les neurosciences dans tout ça ?</strong></p>
<p>De nouvelles recherches en neuroscience ont démontrées que les dendrites des neurones pyramidaux du néocortex (<strong>la couche de substance grise particulièrement développée chez les mammifères et qui forme la paroi des hémisphères cérébraux</strong>) sont en fait capables de classifier des entrées non linéairement séparabes. En d'autres termes, <strong>les dendrites sont capables de calculer la fonction XOR</strong>, et le cerveau est (encore une fois) bien plus complexe que nous le pensions.</p>
<p>Concernant la fonction XOR, il faut un réseau de neurones denses à 2 couches pour pouvoir la calculer.</p>
<p><em>Dendritic action potentials and computation in human layer 2/3 cortical neurons</em>, Albert Gidon, Timothy Adam Zolnik, Pawel Fidzinski, Felix Bolduan, Athanasia Papoutsi, Panayiota Poirazi, Martin Holtkamp, Imre Vida, Matthew Evan Larkum</p>
</div>
<div class="admonition note">
<p class="admonition-title">Récaptulatif</p>
<p>Récapitulatif et suite</p>
<p><img alt="Screenshot" src="../images/image_module1/box.svg" /></p>
</div>
<h2 id="generalisation-les-reseaux-de-neurones-denses">Genéralisation : Les réseaux de neurones denses</h2>
<p>On peut donc résumer la partie précédente dans le diagramme suivant.</p>
<p><img alt="Screenshot" src="../images/image_module1/BNN.svg" /></p>
<p>avec <span class="arithmatex">\(b = -\vartheta\)</span> et la fonction de Heaviside <span class="arithmatex">\(H\)</span> étant ici la fonction d'activation <span class="arithmatex">\(f\)</span>.</p>
<div class="admonition danger">
<p class="admonition-title">Attention</p>
<p>Le Perceptron ne peut faire que de la classification binaire.</p>
</div>
<p>Pour résoudre le problème de la fonction XOR, l'idée est d'empiler de façon hiérarchique en plusieurs couches des Perceptrons succéssifs. On parle alors de Perceptron Multicouche (MLP), premier exemple de réseau de neurones artificiels (ANN).</p>
<p>Pour avoir une notion plus intéréssante, il est nécéssaire de modifier la définition du Perceptron.</p>
<p>Avant toute modification, posons une définition générale, qui nous sera utile dans toute la suite de la formation. c'est celle de <strong>graphe acyclique orienté</strong>.</p>
<p><strong>Structurellement</strong>, un MLP, et donc un ANN, est <strong>un graphe orienté acyclique</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Définition</p>
<ol>
<li>Un <strong>graphe</strong>, est une collection <span class="arithmatex">\(G = (S,A)\)</span> où <span class="arithmatex">\(S\)</span> correspond à la collection des <strong>sommets</strong> et <span class="arithmatex">\(A\)</span> correspond à la collection des <strong>arêtes</strong>.</li>
<li>Un graphe est dit <strong>orienté</strong> lorsque chacune des arêtes possède une orientation.</li>
<li>Un graphe orienté est dit <strong>acyclique</strong> s'il n'y a aucune boucles.</li>
</ol>
<p><img alt="Screenshot" src="../images/image_module1/DAG.svg" /></p>
</div>
<div class="admonition note">
<p class="admonition-title">Définition</p>
<p>Un Perceptron Multicouche est un DAG où chaque sommets est un Perceptron.</p>
</div>
<p>Les neurones correspondent aux sommets et les dendrites et axones correspondent aux arêtes du graphe. Les neurones, ou sommets, sont organisés en couches successives reliées entres elles par les arêtes, les MLP possèdent un point de départ, la couche d'entrée, et un point d'arrivée, la couche de sortie, les couches intermédiaires sont elles appelées les couches cachées.</p>
<p>Généraliser la méthode d'aprentissage du Perceptron à un MLP à plusieurs couches cachées est compliquée, en partie dû au nombres importants de paramètres présents dans les réseaux de neurones.</p>
<p>Le travail révolutionnaire permettant d'entrainer des ANN avec un nombre quelconque de couches cachées en un temps fini, date de 1986. Dans l'article <em>Learning internal representations by error propagations</em>, David Rumelhart, Geoffrey Hinton et Ronald Williams introduise <strong>l'algorithme de rétropropagation</strong> pour l'entraînement.</p>
<p>Cependant, pour que cette algorithme fonctionne, il est nécéssaire de faire des changements dans la définition du MLP. Voyons les changements à éffectuer points par points.</p>
<h3 id="fonction-dactivation-et-etape-feedforward">Fonction d'activation et étape feedforward</h3>
<p>Les fonctions d'activations utilisées dans le Perceptron étant des fonctions de Heaviside. On cette fonction là n'est pas adaptée pour l'algorithme de rétropropagation, le point clé de cette algorithme, qui sera détaillé plus tard, est l'utilisation de la descente du gradient. La fonction de Heaviside étant <strong>constante par morceaux</strong> (et donc une dérivée nulle en tout point), une telle technique ne marche pas dessus.</p>
<p>Il est donc nécéssaire de remplacer ces fonctions de Heaviside par une autre fonction, la fonction d'activation choisie par Rumelhart, Hinton, et Williams pour la remplacer est la fonction sigmoïde (logistique).</p>
<div class="arithmatex">\[
    \begin{array}{ccccc} \sigma &amp; : &amp; \mathbf{R} &amp; \to &amp; [0,1] \\ &amp; &amp; x &amp; \mapsto &amp; \sigma(x) \\ \end{array}
\]</div>
<div class="arithmatex">\[
    \sigma(x) := \frac{1}{1 + \exp(-x)}
\]</div>
<p><img alt="Screenshot" src="../images/image_module1/Logistic.svg" /></p>
<p>La fonction logistique possède, au contraire de la fonction de Heaviside, une dérivée bien définie et non nulle en tout point.</p>
<p>L'algorithme de rétropropagation fonctionne avec de nombreuses autres fonctions d'activations. Avant de définir les autres fonctions, il est utile de distinguer deux types de fonctions d'activations :</p>
<ol>
<li>Les fonctions d'activations uniquement présentes en sortie de couches cachées,</li>
<li>Les fonctions d'activations pouvant être présentes aussi en en sortie du DAG.</li>
</ol>
<p>Le deuxième type de fonction d'activation est très restreint et <strong>dépend de la problématique que l'on souhaite résoudre</strong>.</p>
<ol>
<li>Dans le cas d'un problème de régression linéaire, aucune fonction d'activation en sortie n'est demandée.</li>
<li>Dans le cas d'un problème de classification binaire, la fonction d'activation en sortie sera la fonction logistique</li>
</ol>
<div class="admonition danger">
<p class="admonition-title">Attention</p>
<p>Et dans le cas d'une classification multinomiale ?</p>
</div>
<p>Pour une classification multinomiale, la fonction d'activation privilégiée en sortie du réseau est la fonction softmax</p>
<div class="arithmatex">\[
    \begin{array}{ccccc}
    \mathrm{softmax} &amp; : &amp; \mathbf{R}^{k} &amp; \to     &amp; [0,1]^{k} \\
                     &amp;   &amp; x              &amp; \mapsto &amp; \mathrm{softmax}(x) \\
    \end{array}
\]</div>
<div class="arithmatex">\[\mathrm{softmax}(x) := (\frac{\exp(x_{1})}{\sum_{i=1}^{k}\exp(x_{i})}, \dots, \frac{\exp(x_{k})}{\sum_{i=1}^{k}\exp(x_{i})})\]</div>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>Dans le cas d'un problème de classification binaire, il est aussi possible d'utiliser en sortie la fonction softmax <strong>à condition d'avoir modifier la cible</strong> <span class="arithmatex">\(\mathbf{y}_{i}\)</span> <strong>par un One-hot Encoding</strong>, ce cas là sera traîté en TP.</p>
</div>
<p>Dans le cas des  fonctions d'activations uniquement présentes en sortie de couches cachées, on a un plus grand choix possibles. Dans la pratique cependant, 2 fonctions d'activations sont plus utilisées que les autres.</p>
<p>La fonction d'activation devenue un standard est la fonction <span class="arithmatex">\(\mathrm{ReLU}\)</span> : Rectified Linear Unit, définie par</p>
<div class="arithmatex">\[
    \begin{array}{ccccc} \mathrm{ReLU} &amp; : &amp; \mathbf{R} &amp; \to     &amp; \mathbf{R} \\
                                       &amp;   &amp; x              &amp; \mapsto &amp; \mathrm{ReLU}(x) \\
    \end{array}
\]</div>
<div class="arithmatex">\[\mathrm{ReLU}(x) := \max(0,x)\]</div>
<p><img alt="Screenshot" src="../images/image_module1/relu.svg" /></p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<ol>
<li>
<p>La fonction <span class="arithmatex">\(\mathrm{ReLU}\)</span> n'est utilisée qu'en sortie des couches cachées, et non pas en sortie du  réseau.</p>
</li>
<li>
<p>La fonction <span class="arithmatex">\(\mathrm{ReLU}\)</span> n'est pas différentiable en 0, et sa dérivée est nulle pour <span class="arithmatex">\(x&lt;0\)</span>. Dans la pratique cependant, elle fonctionne très bien et surtout, sa dérivée est très rapide à calculer.</p>
</li>
</ol>
</div>
<p>Un deuxième choix, aussi très courant, est la fonction tangente hyperbolique, <span class="arithmatex">\(\tanh\)</span>.</p>
<div class="arithmatex">\[
    \begin{array}{ccccc} \tanh         &amp; : &amp; \mathbf{R} &amp; \to     &amp; [-1,1] \\
                                       &amp;   &amp; x          &amp; \mapsto &amp; \frac{\mathrm{e}^{x}-\mathrm{e}^{-x}}{\mathrm{e}^{x}+\mathrm{e}^{-x}} \\
    \end{array}
\]</div>
<p><img alt="Screenshot" src="../images/image_module1/tanh.svg" /></p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>Les fonctions d'activations doivent posséder les caractéristiques suivantes.</p>
<ul>
<li>La fonction doit être continue et définie partout,</li>
<li>La fonction doit être monotone,</li>
<li>La fonction ne doit pas être linéaire,</li>
<li>La fonction, et ses dérivées, doit être facilement calculable.</li>
</ul>
</div>
<p>Le parcours complet d'une observation <span class="arithmatex">\(\mathbf{x}_{i}\)</span> à travers le DAG se nomme dans le jargon l'étape de feedforward. Pour que cela soit plus clair, voyons celas sur un exemple.</p>
<p><img alt="Screenshot" src="../images/image_module1/activation_functions_plot.svg" /></p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p>Définissons un exemple d'étape feedforward.</p>
<p><img alt="Screenshot" src="../images/image_module1/ANN_final.svg" /></p>
<p>On a deux entrées <span class="arithmatex">\(x_{1}, x_{2}\)</span>, et une sortie <span class="arithmatex">\(\hat{y}\)</span>. On peut donc supposer que les observations du dataset sont de la forme <span class="arithmatex">\((x_{1}, x_{2}, y)\)</span>.</p>
<ol>
<li>
<p><strong>Etape 1</strong> : Les features de l'observation <span class="arithmatex">\((x_{1}, x_{2})\)</span> sont passées en entrée, chacune de ces features est envoyée à chaucn des neurones <span class="arithmatex">\(h_{1}, h_{2}\)</span> de l'unique couche cachée. Les connexions étant pondérées, <strong>la règle des noeuds</strong> s'applique et au niveau de la couche cachée on se retrouve avec les valeurs <span class="arithmatex">\(z_{1}, z_{2}\)</span> définiées par l'équation <span class="arithmatex">\((1)\)</span>, ou de façon équivalente par l'équation <span class="arithmatex">\((2)\)</span> sous forme matricielle. La matrice <span class="arithmatex">\(2 \times 2\)</span> de l'équation <span class="arithmatex">\((2)\)</span> est la matrice de poids de la couche cachée.</p>
</li>
<li>
<p><strong>Etape 2</strong> : En sortie de la couche cachée, la fonction d'activation <span class="arithmatex">\(\sigma^{1}\)</span> s'applique, on est alors à l'équation <span class="arithmatex">\((3)\)</span> avec les valeurs <span class="arithmatex">\((y_{1}, y_{2})\)</span>.</p>
</li>
<li>
<p><strong>Etape 3</strong> : En arrivant au neurone de sortie, une nouvelle loi des noeuds s'applique à l'intérieur du neurone rouge, puis la fonction d'activation <span class="arithmatex">\(\sigma^{2}\)</span>. D'où l'équation <span class="arithmatex">\((4)\)</span>.</p>
</li>
</ol>
</div>
<p>Le vecteur <span class="arithmatex">\(\hat{y}\)</span> que l'on a en sortie de l'étape de feedforward pour l'observation <span class="arithmatex">\(x_{1}, x_{2}\)</span> est alors cible prédite (ou simplement prédiction) par l'ANN. Comment alors mesurer l'erreur faite en prédisant <span class="arithmatex">\(\hat{y}\)</span> par rapport à la cible <span class="arithmatex">\(y\)</span> ?</p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p><img alt="Screenshot" src="../images/image_module1/DAG.svg" /></p>
<p>Un réseau de neurones dense avec 3 couches cachées, 5 entrées et 3 sorties, on peut supposer que l'on est dans le cas d'un problème de classification avec 3 classes distinctes.</p>
</div>
<h3 id="fonction-de-perte">Fonction de perte</h3>
<p>La fonction de perte est là pour calculer l'erreur obtenue entre la prédiction et la cible. Elle est traditionnelement notée <span class="arithmatex">\(\mathcal{L}_{\theta}\)</span>.</p>
<p>Suivant le but du réseau de neurone on a plusieurs fonctions de pertes standards.</p>
<table>
<thead>
<tr>
<th align="center">But</th>
<th align="center">Fonction de pertes</th>
<th align="center">Activation</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Régression</td>
<td align="center">Erreur Moyenne Absolue (MAE)</td>
<td align="center">aucune</td>
</tr>
<tr>
<td align="center">Régression</td>
<td align="center">Erreur Moyenne Quadratique (MSE)</td>
<td align="center">aucune</td>
</tr>
<tr>
<td align="center">Classification Binomiale</td>
<td align="center">Entropie Croisée Binomiale  (BCE)</td>
<td align="center">sigmoïde</td>
</tr>
<tr>
<td align="center">Classification Binomiale (One Hot Encoding)</td>
<td align="center">Entropie Croisée Catégorielle (CCE)</td>
<td align="center">softmax</td>
</tr>
<tr>
<td align="center">Classification multinomiale</td>
<td align="center">Entropie Croisée Catégorielle Eparse (SCCE)</td>
<td align="center">softmax</td>
</tr>
<tr>
<td align="center">Classification multinomiale (One Hot Encoding)</td>
<td align="center">Entropie Croisée Catégorielle (CCE)</td>
<td align="center">softmax</td>
</tr>
</tbody>
</table>
<p>Dans le cadre des problèmes de classification, les noms des fonctions de pertes peut être différents mais la formule est fondamentalement la même. les modifications apportées ne sont là que pour prendre en compte la forme des prédictions et cibles : est ce que la classe est représentée par un vecteur ou simplement par un nombre ?</p>
<div class="arithmatex">\[
    MAE := \frac{1}{N}\sum_{i=1}^{N} ||y_{i} - \hat{y}_{i}||_{1}
\]</div>
<div class="arithmatex">\[
    MSE := \frac{1}{N}\sum_{i=1}^{N} ||y_{i} - \hat{y}_{i}||^{2}_{2}
\]</div>
<div class="arithmatex">\[
    CE := -\frac{1}{N}\sum_{i=1}^{N} \langle y_{i}, \log(\hat{y}_{i}) \rangle
\]</div>
<p>Le nombre <span class="arithmatex">\(N\)</span> présent dans les formules ci dessus est la taille du minibatch d'observations, pour l'instant on peut supposer que <span class="arithmatex">\(N=32\)</span>. Sa définition sera claire par la suite.</p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>Dans le jargon, elle est appelée <strong>loss function</strong> et est traditionnelement notée <span class="arithmatex">\(\mathcal{L}_{\theta}\)</span>, où <span class="arithmatex">\(\theta\)</span> représente les poids et biais du réseau.</p>
</div>
<p>On a fait une étape de feedforward, on a obtenu une prédiction <span class="arithmatex">\(\hat{y}\)</span> dont on a calculée l'erreur <span class="arithmatex">\(\mathcal{L}_{\theta}(\hat{y})\)</span> grâce à a fonction de perte <span class="arithmatex">\(\mathcal{L}_{\theta}\)</span>. La question qui se pose maintenant est la suivante.</p>
<p><strong>Comment minimiser cette erreur ?</strong></p>
<h3 id="descente-du-gradient-stochastique">Descente du gradient stochastique</h3>
<p>De façon succinte, on utilise la methode de la technique du gradient couplée à une méthode efficace pour calculer automatiquement le gradient.</p>
<div class="admonition note">
<p class="admonition-title">Descente du gradient</p>
<p>La méthode de la descente du gradient est un algorithme d'optimisation permettant de trouver le minimum d'une fonction <span class="arithmatex">\(f\)</span>. Pour simplifier l'explication, supposons que l'on considère la fonction d'une seule variable.</p>
<div class="arithmatex">\[
    \begin{array}{ccccc}
    C &amp; : &amp; \mathbf{R} &amp; \to     &amp; \mathbf{R} \\
      &amp;   &amp; w          &amp; \mapsto &amp; C(w) \\
    \end{array}
\]</div>
<p>La méthode pour trouver un minimum de <span class="arithmatex">\(C\)</span> est alors d'appliquer l'algorithme suivant :</p>
<p><strong>Initialisation</strong></p>
<ol>
<li>Choisir un point de départ <span class="arithmatex">\(w \in \mathrm{dom}(C)\)</span>.</li>
<li>Choisir un pas <span class="arithmatex">\(\eta\)</span> "très petit".
    <strong>et répéter :</strong><ol>
<li>Calculer <span class="arithmatex">\(C'(w)\)</span></li>
<li>Mettre à jour <span class="arithmatex">\(w := w - \eta C'(w)\)</span></li>
</ol>
</li>
</ol>
<p>Si <span class="arithmatex">\(w\)</span> est un minimum de <span class="arithmatex">\(C\)</span>, alors <span class="arithmatex">\(C'(w) = 0\)</span> et l'étape 2 de la phase de répétition reste bloquée sur <span class="arithmatex">\(w\)</span>.</p>
<p><img alt="Screenshot" src="../images/image_module1/gradient-descent-optimized.gif" /></p>
<p>Exemple de descente du gradient (mlfromscratch)</p>
</div>
<p>La descente du gradient se généralise de la même façon à une fonction de plusieurs variables. Pour une fonction</p>
<div class="arithmatex">\[f \, : \, \mathbf{R}^{k} \longrightarrow \mathbf{R}\]</div>
<p>Les étapes 2.a et 2.b ci dessus sont alors remplacées par les étapes suivantes.</p>
<ol>
<li>Calculer <span class="arithmatex">\(\nabla f := ( \frac{\partial f}{\partial x_{1}}, \dots, \frac{\partial f}{\partial x_{k}})\)</span></li>
<li>Mettre à jour <span class="arithmatex">\(w := w - \eta \nabla f\)</span></li>
</ol>
<p>Le but de la descente du gradient étant de déterminer le minimum d'une fonction, la question que l'on peut se poser de façon légitime est alorsla suivante : si l'on utilise la descente du gradient ici, quelle fonction souhaite-t-on minimiser ? Dans le cas du Deep Learning, la fonction que l'on cherche à minimiser est <strong>la fonction de perte moyenne totale</strong>.</p>
<div class="arithmatex">\[
    \mathcal{L}_{\theta}^{\mathrm{tot}} := \frac{1}{n} \sum_{i=1}^{n} \mathcal{L}_{\theta}(\hat{y}_{i})
\]</div>
<p>On rappelle que <span class="arithmatex">\(n\)</span> est le cardinal de <span class="arithmatex">\(\mathcal{X}\)</span>, ie le nombre total d'observations dans le dataset. On notera <span class="arithmatex">\(\theta\)</span> <strong>l'ensemble des paramètres du réseau</strong>, on pose <span class="arithmatex">\(p\)</span> son cardinal, (le nombre total de paramètres, poids et biais combiné) il peut aller d'une dizaine à plusieurs milliards pour les modèles les plus récents.</p>
<p>On a donc l'ensemble suivant,</p>
<div class="arithmatex">\[
    \theta := \lbrace w_{1}, \dots, w_{\alpha}, b_{1}, \dots, b_{\beta} \rbrace \quad \alpha + \beta = p
\]</div>
<p>Reste alors à savoir par rapport à quelles variables l'on souhaite calculer le gradient. Rapellons nous que dans la fonction de perte, pour une observation donnée <span class="arithmatex">\(y_{i}\)</span>, <span class="arithmatex">\(\hat{y}_{i}\)</span> est une combinaison des éléments de <span class="arithmatex">\(y_{i}\)</span> et des paramètres du réseau, la valeur de <span class="arithmatex">\(y_{i}\)</span> étant fixe, <strong>la seule chose qui peut varier dans la fonction de perte est la valeur des paramètres</strong> <span class="arithmatex">\(\theta\)</span>.</p>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>Le but de l'algorithme de rétropropagation du gradient est de trouver les paramètres <span class="arithmatex">\(\theta\)</span> optimaux pour minimiser la fonction de perte. Le gradient à calculer est donc le suivant.</p>
<div class="arithmatex">\[
    \nabla_{\theta} \mathcal{L}_{\theta}^{\mathrm{tot}} := \begin{pmatrix}
    \frac{\partial \mathcal{L}_{\theta}^{\mathrm{tot}}}{\partial w_{1}} \\
    \frac{\partial \mathcal{L}_{\theta}^{\mathrm{tot}}}{\partial w_{2}} \\
    \vdots  \\
    \frac{\partial \mathcal{L}_{\theta}^{\mathrm{tot}}}{\partial w_{\alpha}} \\
    \frac{\partial \mathcal{L}_{\theta}^{\mathrm{tot}}}{\partial b_{1}} \\
    \vdots \\
    \frac{\partial \mathcal{L}_{\theta}^{\mathrm{tot}}}{\partial b_{\beta}}
    \end{pmatrix}
\]</div>
</div>
<p>Calculer ce gradient se fait alors via l'algorithme dit <strong>d'auto-différentiation inverse</strong>, c'est le choix fait par Tensorflow.</p>
<div class="admonition example">
<p class="admonition-title">Exemple : Graphe de calcul et auto-différentiation inverse</p>
<p>On prend l'exemple de la fonction suivante.</p>
<div class="arithmatex">\[
    f(x) := \log(x) + \sqrt{\log(x)}
\]</div>
<p>On souhaite calculer sa dérivé, son graphe de calcul est alors le suivant.</p>
<p>.. figure :: image_module1/autodiff_final.svg
    :align: center</p>
<p>L'algorithme d'auto-différentiation prend alors la forme suivante.</p>
<div class="arithmatex">\[
    \begin{align}
    (1) \quad \frac{\partial f}{\partial f} &amp; = 1 \\
    (2) \quad \frac{\partial f}{\partial z} &amp; = \frac{\partial f}{\partial f} \cdot \frac{\partial f}{\partial z} =\frac{\partial f}{\partial f}1 \\
    (3) \quad \frac{\partial f}{\partial y} &amp; = \frac{\partial f}{\partial z} \cdot \frac{\partial z}{\partial y} + \frac{\partial f}{\partial f}\cdot \frac{\partial f}{\partial y} = \frac{\partial f}{\partial z}\cdot \frac{1}{2\sqrt{y}} + \frac{\partial f}{\partial f}1 \\
    (4) \quad \frac{\partial f}{\partial x} &amp; = \frac{\partial f}{\partial y}\cdot \frac{\partial y}{\partial x} = \frac{\partial f}{\partial y} \cdot\frac{1}{x}
    \end{align}
\]</div>
</div>
<p>Le but de la descente du gradient dans l'algorithme de rétropropagation est alors de minimiser cette fonction de perte, <strong>et donc de minimiser l'erreur moyenne faite durant la prédiction</strong>. Cependant pour un dataset comprenant plusieurs millions d'observations calculer le gradient <strong>complet</strong> <span class="arithmatex">\(\nabla_{\theta}\mathcal{L}_{\theta}\)</span> est prohibitf. L'idée est alors d'échanger ce gradient complet pour un gradient <strong>approximatif mais plus simple à calculer</strong>. C'est le principe du minibatch.</p>
<p>De façon plus détaillée, voici comment fonctionne l'algorithme :</p>
<div class="admonition note">
<p class="admonition-title">Algorithme de rétropropagation</p>
<ol>
<li>
<p>L'algorithme considère <strong>un minibatch de taile</strong> <span class="arithmatex">\(N\)</span> <strong>à la fois</strong> (par exemple, avec <span class="arithmatex">\(N=32\)</span> observations à chaque fois), lorsque l'on parle de mini-batch de taille <span class="arithmatex">\(N\)</span> il faut comprendre <strong>sélection de</strong> <span class="arithmatex">\(N\)</span> <strong>observations par un tirage sans remise</strong>. Chaque passage du dataset complet s'appelle <strong>une époque</strong>.</p>
</li>
<li>
<p>Durant l'étape de feedforward, chaque passage du mini-batch dans une couche du réseau le résultat obtenu est conservé en mémoire.</p>
</li>
<li>
<p>Une fois le mini-batch passé complètement dans l'ANN, la prédiction est alors évaluée avec <strong>la fonction de perte</strong> pour en déduire l'erreur de prédiction faite par rapport par rapport à la cible.</p>
</li>
<li>
<p>L'algorithme calcule alors la contribution de chacun des poids et biais dans le calcul de l'erreur obtenue par la fonction de perte.</p>
</li>
<li>
<p><strong>Une descente du gradient sur la fonction de perte</strong> est alors appliquée pour modifier les poids et les biais, et à terme minimiser la fonction de perte.</p>
</li>
</ol>
</div>
<p>La mise à jour des paramètres de l'ANN se faisant suite au passage du mini-batch, la technique de descente du gradient utilisée ici est dite <strong>descente du gradient stochastique</strong>, stochastique faisant référence ici à la manière aléatoire par laquelle sont sélectionnées les observations composants le mini-batch.</p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p>La méthode du gradient est utilisé pour optimiser les paramètres du réseau de neurones. Les étapes sont les suivantes.</p>
<ol>
<li>Comme on travaille en mini-batch de taille <span class="arithmatex">\(N\)</span> (eg <span class="arithmatex">\(N=32\)</span>) on a une valeur d'erreur pour chaque prédictions faite sur ce mini-batch.</li>
</ol>
<div class="arithmatex">\[
    \mathcal{L}_{\theta}(\hat{y}_{1}), \mathcal{L}_{\theta}(\hat{y}_{2}), \dots, \mathcal{L}_{\theta}(\hat{y}_{N})
\]</div>
<ol>
<li>La fonction que l'on va donc utiliser pour appliquer la méthode du gradient est <strong>la fonction de perte moyenne</strong> sur ce mini-batch.</li>
</ol>
<div class="arithmatex">\[
    \mathcal{L}_{\theta} := \frac{1}{N} \sum_{i=1}^{N} \mathcal{L}_{\theta}(\hat{y}_{i})
\]</div>
<ol>
<li>Le gradient de cette fonction est alors défini par :</li>
</ol>
<div class="arithmatex">\[
    \nabla_{\theta} \mathcal{L}_{\theta} := \begin{pmatrix}
    \frac{\partial \mathcal{L}_{\theta}}{\partial w_{1}} \\
    \frac{\partial \mathcal{L}_{\theta}}{\partial w_{2}} \\
    \vdots  \\
    \frac{\partial \mathcal{L}_{\theta}}{\partial w_{\alpha}} \\
    \frac{\partial \mathcal{L}_{\theta}}{\partial b_{1}} \\
    \vdots \\
    \frac{\partial \mathcal{L}_{\theta}}{\partial b_{\beta}}
    \end{pmatrix}
\]</div>
<ol>
<li>La mise à jour des paramètres se fait alors via la formule suivante :</li>
</ol>
<div class="arithmatex">\[
    w_{i} - \eta \frac{\partial \mathcal{L}_{\theta}}{\partial w_{i}}(\theta)
\]</div>
<div class="arithmatex">\[
    b_{i} - \eta \frac{\partial \mathcal{L}_{\theta}}{\partial b_{i}}(\theta)
\]</div>
<p><span class="arithmatex">\(\eta\)</span> est ici un nombre réel que l'on appelle le taux d'apprentissage, il n'est pas appris par l'algorithme et doit être fixé à la main (c'est un hyperparamètre).</p>
</div>
<div class="admonition question">
<p class="admonition-title">Pourquoi choisir une méthode stochastique ?</p>
<p>Etant donnée une fonction différentiable, il est théoriquement possible de trouver son minimum de façon purement analytique : une fonction <span class="arithmatex">\(f : \mathbf{R} \rightarrow \mathbf{R}\)</span> possède un extremum en un point <span class="arithmatex">\(x\)</span> si sa dérivée <span class="arithmatex">\(f'(x)\)</span> est nulle. Une fois trouvé tous ces points on prend celui pour lequel <span class="arithmatex">\(f(x)\)</span> est la plus petite valeur.</p>
<p>Dans le cadre des réseaux de neurones, cela revient à devoir résoudre <span class="arithmatex">\(\nabla \mathcal{L}_{\theta} = 0\)</span>. C'est une équation polynomiale en <span class="arithmatex">\(p\)</span> variables, où <span class="arithmatex">\(p\)</span> est le cardinal de <span class="arithmatex">\(\theta\)</span> ensemble des paramètres du réseau.</p>
<p>Premièrement, si cela est faisable pour <span class="arithmatex">\(p=2\)</span> ou <span class="arithmatex">\(p=3\)</span>, c'est difficilement réalisable dans la pratique d'une réseau de neurones où <span class="arithmatex">\(p\)</span> dépasse facilement la centaine de milliers.</p>
<p>Deuxièmement, effectuer une descente du gradient classique supposerait d'avoir calculé les prédictions sur l'ensemble du dataset, et de garder en mémoire ces valeurs afin de calculer <span class="arithmatex">\(\nabla \mathcal{L}_{\theta}\)</span>.</p>
<p><strong>Du point de vue de la complexité algorithmique, le coût de calcul de</strong> <span class="arithmatex">\(\nabla \mathcal{L}_{\theta}=0\)</span> <strong>croît alors de façon linéaire avec la taille du dataset</strong>.</p>
<p>Dans une méthode stochastique, la taille du mini-batch étant fixée (eg <span class="arithmatex">\(N=32\)</span>) et relativement petite par rapport à la taille du dataset, la compléxité est moindre et constante tout au long de l'algorithme. Les mises à jour des paramètres étant plus fréquentes,
l'algorithme converge plus rapidement vers un optimum.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Remarque</p>
<p>La descente du gradient, stochastique ou non, est à la base une méthode d'<strong>optimisation convexe</strong>, hors <strong>les fonctions de pertes utilisées dans la pratique ne sont pas convexes</strong>. On se retrouve donc généralement uniquement avec des minima locaux pour la fonction de perte. Dans la pratique ce n'est pas un soucis, et de nombreuses techniques d'optimisation ont été introduites pour pouvoir converger vers un minimum global au lieu de "rester coincé dans un minimum local". Méthodes que l'on verra dans les modules suivants.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Symétrie des poids</p>
<p><img alt="Screenshot" src="../images/image_module1/symmetry_final.svg" /></p>
<p><img alt="Screenshot" src="../images/image_module1/symmetry_matrix.svg" /></p>
</div>
<p>La descente du gradient stochastique, n'est qu'une des méthodes d'optimisation afin de minimiser la fonction de perte. Il existe aujourd'hui de nombreux <strong>optimiseurs</strong> pour la descente du gradient.</p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p>Définissons un exemple de l'étape de rétropropagation du gradient.</p>
<p><img alt="Screenshot" src="../images/image_module1/backprop_final.svg" /></p>
<div class="arithmatex">\[
\begin{align}
    \frac{\partial \mathcal{L}_{\vartheta}}{ \partial w_{1,1}^{1}} =  &amp; \frac{\partial \mathcal{L}_{\vartheta}}{\partial s} \cdot \frac{\partial s}{\partial h_{1}^{2}} \cdot \frac{\partial h_{1}^{2}}{\partial h_{1}^{1}} \cdot \frac{\partial h_{1}^{1}}{\partial w_{1,1}^{1}} \\
                                                                    + &amp; \frac{\partial \mathcal{L}_{\vartheta}}{\partial s} \cdot \frac{\partial s}{\partial h_{2}^{2}}
    \cdot \frac{\partial h_{2}^{2}}{\partial h_{1}^{1}} \cdot \frac{\partial h_{1}^{1}}{\partial w_{1,1}^{1}}
\end{align}
\]</div>
<div class="arithmatex">\[
    w_{1,1}^{1} \leftarrow w_{1,1}^{1} - \eta \frac{\partial \mathcal{L}_{\vartheta}}{ \partial w_{1,1}^{1}}.
\]</div>
</div>
<p>Les neurones denses sont une généralisation très puissante des MLP, car <strong>ce sont des approximateurs universels</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Théorème d'approximation universelle de Kolmogorov</p>
<p>Toute fonction continue définie sur un compact <span class="arithmatex">\(K \subset \mathbf{R}^{r}\)</span> peut être uniformément approximée par un réseau de neurones denses avec une couche cachée.</p>
</div>
<h2 id="resume">Résumé</h2>
<p>Mathématiquement, un MLP peut se représenter par la fonction suivante.</p>
<div class="arithmatex">\[
    \begin{array}{ccccc} f_{NN} &amp; : &amp; \mathbf{R}^{m} &amp; \to &amp; \mathbf{R}^{k} \\ &amp; &amp; \mathbf{x} &amp; \mapsto &amp; f_{NN}(\mathbf{x}) \\ \end{array}
\]</div>
<div class="arithmatex">\[
    \hat{\mathbf{y}} := f_{NN}(\mathbf{x}) = \sigma^{r} \circ \cdots \circ \sigma^{1} (\mathbf{x})
\]</div>
<p>L'entier <span class="arithmatex">\(m\)</span> dépend du nombre de features dans le dataset, l'entier <span class="arithmatex">\(k\)</span> dépend lui du problème considéré.</p>
<p>Le nombre de fonctions <span class="arithmatex">\(\sigma^{i}\)</span> dépend de l'architecture du réseau et correspond au nombre de couches cachées.</p>
<div class="arithmatex">\[
    \mathbf{y}^{\ell} := \sigma^{\ell}(\mathbf{X}\mathbf{W}_{\ell} + \mathbf{b}_{\ell})
\]</div>
<p>Où <span class="arithmatex">\(\mathbf{W}_{\ell}\)</span> correspond à la matrice de poids de la couche <span class="arithmatex">\(\ell\)</span> et <span class="arithmatex">\(\mathbf{b}_{\ell}\)</span> au vecteur de biais correspondant. On a</p>
<ol>
<li>Une ligne par features dans <span class="arithmatex">\(\mathbf{X}\)</span>,</li>
<li>Une colonne par neurones dans la couche cachée,</li>
<li>Autant de biais que de neurones dans la couche cachée.</li>
</ol>
<div class="arithmatex">\[
    \begin{equation*}
    \mathbf{W}_{\ell} = \begin{pmatrix}
    w_{1,1}^{\ell} &amp; w_{1,2}^{\ell} &amp; \cdots &amp; w_{1,r}^{\ell} \\
    w_{2,1}^{\ell} &amp; w_{2,2}^{\ell} &amp; \cdots &amp; w_{2,r}^{\ell} \\
    \vdots  &amp; \vdots  &amp; \ddots &amp; \vdots  \\
    w_{l,1}^{\ell} &amp; w_{l,2}^{\ell} &amp; \cdots &amp; w_{l,r}^{\ell}
    \end{pmatrix}\end{equation*}
    \in \mathcal{M}_{l,r}(\mathbf{R}) \quad \mathbf{b}_{\ell} = \begin{pmatrix}b_{1}^{\ell} &amp; b_{2}^{i} &amp; \cdots &amp; b_{r}^{\ell} \end{pmatrix}
\]</div>
<p><strong>La topologie du réseau</strong> : Le nombres de neurones, de couches, de neurones par couches, et d'arrêtes dépendent du problème considéré. Il existe toutefois des architectures connues et spécialisées dans certains problèmes. Certaines couches de neurones sont ainsi spécialisées dans le traitement d'images, d'autres encore dans le traitement des séries temporelles.</p>
<div class="admonition example">
<p class="admonition-title">Exemple</p>
<p><img alt="Screenshot" src="../images/image_module1/DAG.svg" /></p>
<p>Un réseau de neurones dense avec 3 couches cachées, 5 entrées et 3 sorties, on peut supposer que l'on est dans le cas d'un problème de classification avec 3 classes distinctes.</p>
<ol>
<li>La première couche cachée a pour matrice de poids une matrice de taille <span class="arithmatex">\(5\times 10\)</span>,  <span class="arithmatex">\(\mathbf{W}_{1} \in \mathcal{M}_{5,10}(\mathbf{R})\)</span>,</li>
<li>La deuxième couche cachée a pour matrice de poids une matrice de taille <span class="arithmatex">\(10\times 10\)</span>,  <span class="arithmatex">\(\mathbf{W}_{2} \in \mathcal{M}_{10,10}(\mathbf{R})\)</span>,</li>
<li>La troisème couche cachée a pour matrice de poids une matrice de taille <span class="arithmatex">\(10\times 10\)</span>,  <span class="arithmatex">\(\mathbf{W}_{3} \in \mathcal{M}_{10,10}(\mathbf{R})\)</span>,</li>
<li>La couche de sortie a pour matrice de poids une matrice de taille <span class="arithmatex">\(10\times 3\)</span>,  <span class="arithmatex">\(\mathbf{W}_{4} \in \mathcal{M}_{10,3}(\mathbf{R})\)</span>.</li>
</ol>
<p>Concernant les biais on a des vecteurs :</p>
<ol>
<li><span class="arithmatex">\(\mathbf{b}_{1} \in \mathbf{R}^{10}\)</span> pour la première couche cachée,</li>
<li><span class="arithmatex">\(\mathbf{b}_{2} \in \mathbf{R}^{10}\)</span> pour la deuxième couche cachée,</li>
<li><span class="arithmatex">\(\mathbf{b}_{3} \in \mathbf{R}^{10}\)</span> pour la troisième couche cachée,</li>
<li><span class="arithmatex">\(\mathbf{b}_{4} \in \mathbf{R}^{3}\)</span> pour la couche de sortie.</li>
</ol>
<p>Ce qui nous fait un nombre total de paramètres égal à</p>
<p><span class="arithmatex">\(\dim( \mathcal{M}_{5,10}(\mathbf{R})) + \dim(\mathbf{R}^{10}) + \dim( \mathcal{M}_{10,10}(\mathbf{R})) + \dim(\mathbf{R}^{10}) +\dim( \mathcal{M}_{10,10}(\mathbf{R})) + \\ \dim(\mathbf{R}^{10}) + \dim( \mathcal{M}_{10,3}(\mathbf{R})) + \dim(\mathbf{R}^{3}) = 313\)</span></p>
<p>313 paramètres, ce qui est loin d'être énorme.</p>
<p>En python, avec tensorflow, un tel réseau ce code de la manière suivante.</p>
<div class="highlight"><pre><span></span><code>    <span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Input&#39;</span><span class="p">),</span>
    <span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;relu&#39;</span><span class="p">),</span>
    <span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;relu&#39;</span><span class="p">),</span>
    <span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;relu&#39;</span><span class="p">),</span>
    <span class="n">Dense</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
    <span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;softmax&#39;</span><span class="p">)</span>
    <span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SeqAPI&#39;</span><span class="p">)</span>
</code></pre></div>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href=".." class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Précédent
                </span>
                Acceuil
              </div>
            </div>
          </a>
        
        
          <a href="../Module1_2/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Suivant
                </span>
                Pratique
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.7e0ee788.min.js"></script>
      <script src="../assets/javascripts/bundle.b3a72adc.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copier dans le presse-papier", "clipboard.copied": "Copi\u00e9 dans le presse-papier", "search.config.lang": "fr", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Rechercher", "search.result.placeholder": "Taper pour d\u00e9marrer la recherche", "search.result.none": "Aucun document trouv\u00e9", "search.result.one": "1 document trouv\u00e9", "search.result.other": "# documents trouv\u00e9s", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../javascripts/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>